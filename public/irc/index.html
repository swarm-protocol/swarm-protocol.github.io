<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#f5f3ef">
    <link rel="icon" href="../../icon-192.png" sizes="192x192">
    <link rel="apple-touch-icon" href="../../icon-192.png">
    <title>IRC</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xz/fonts@1/serve/jetbrains-mono.min.css">
    <style>
        *{font-family:'JetBrains Mono',monospace;box-sizing:border-box;-webkit-tap-highlight-color:transparent;margin:0;padding:0}
        html,body{width:100%;height:100vh;height:100dvh;background:linear-gradient(135deg,#f5f3ef,#e8e3db);overscroll-behavior:none;overflow:hidden}

        .shell{width:100%;height:100vh;height:100dvh;display:flex;flex-direction:column}

        .top-bar{flex-shrink:0;z-index:100;width:100%;background:rgba(255,255,255,.92);backdrop-filter:blur(20px);border-bottom:3px solid #6b5d52;padding:8px 12px;display:flex;align-items:center;gap:8px}
        .top-bar a{color:#9a77ff;text-decoration:none;font-size:16px;font-weight:700;flex-shrink:0;display:flex;align-items:center}
        .top-title{flex:1;font-size:11px;font-weight:700;color:#89530e;text-transform:uppercase;letter-spacing:1px;text-align:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .top-status{font-size:8px;font-weight:600;padding:2px 6px;border-radius:8px;flex-shrink:0}
        .top-status.off{background:#cc785c;color:#fff}
        .top-status.on{background:#3a8f6b;color:#fff}
        .top-status.connecting{background:#c19a6b;color:#fff;animation:pulse 1.2s ease-in-out infinite}
        @keyframes pulse{0%,100%{opacity:.6}50%{opacity:1}}

        /* Connect view */
        .connect-view{flex:1;display:flex;align-items:center;justify-content:center;padding:12px}
        .connect-view.hidden{display:none}
        .connect-card{background:rgba(255,255,255,.92);backdrop-filter:blur(20px);border:3px solid #6b5d52;outline:3px solid #c19a6b;border-radius:12px;padding:20px;box-shadow:12px 12px 0 rgba(107,93,82,.2);width:100%;max-width:360px}
        .connect-label{color:#89530e;font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:1.5px;margin-bottom:4px;margin-top:10px}
        .connect-label:first-child{margin-top:0}
        .connect-input{width:100%;padding:10px;font-family:inherit;font-size:11px;font-weight:600;color:#1a1a1a;background:#fff;border:2px solid #c19a6b;border-radius:4px;outline:none}
        .connect-input:focus{border-color:#9a77ff;box-shadow:0 0 0 2px rgba(154,119,255,.2)}
        .connect-hint{color:#6b5d52;font-size:8px;margin-top:2px;line-height:1.4}
        .connect-title{color:#89530e;font-size:12px;font-weight:700;text-transform:uppercase;letter-spacing:1.5px;text-align:center;margin-bottom:12px}
        .btn-connect{display:flex;align-items:center;justify-content:center;width:100%;height:44px;background:linear-gradient(135deg,#9a77ff,#7c5ce0);color:#fff;font-weight:700;border:2px solid #6b5d52;outline:2px solid #c19a6b;box-shadow:4px 4px 0 rgba(107,93,82,.3);transition:all .12s;cursor:pointer;font-family:inherit;font-size:10px;text-transform:uppercase;letter-spacing:1px;margin-top:14px;border-radius:0}
        .btn-connect:hover{box-shadow:6px 6px 0 rgba(107,93,82,.3)}
        .btn-connect:active{transform:translate(2px,2px);box-shadow:0 0 0}
        .btn-connect:disabled{opacity:.4;cursor:not-allowed;transform:none!important}

        /* Chat view */
        .chat-view{flex:1;display:none;flex-direction:column;min-height:0}
        .chat-view.active{display:flex}

        .channel-bar{flex-shrink:0;background:rgba(255,255,255,.8);border-bottom:1px solid #e8e3db;padding:4px 12px;display:flex;align-items:center;gap:6px;font-size:9px}
        .channel-name{color:#9a77ff;font-weight:700;font-size:10px}
        .channel-topic{color:#6b5d52;font-weight:500;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .user-count{color:#89530e;font-weight:700;font-size:9px;flex-shrink:0}

        .messages{flex:1;overflow-y:auto;padding:6px 10px;display:flex;flex-direction:column;gap:1px;min-height:0;-webkit-overflow-scrolling:touch;overscroll-behavior:contain;scrollbar-width:thin}
        .messages::-webkit-scrollbar{width:4px}
        .messages::-webkit-scrollbar-thumb{background:#c19a6b;border-radius:2px}

        .msg{display:flex;gap:6px;padding:2px 0;font-size:11px;line-height:1.5;word-break:break-word}
        .msg-time{color:#999;font-size:9px;flex-shrink:0;min-width:36px;font-weight:500;padding-top:1px}
        .msg-nick{font-weight:700;flex-shrink:0;cursor:default}
        .msg-text{flex:1;color:#1a1a1a;min-width:0}
        .msg-text a{color:#9a77ff;text-decoration:none}
        .msg-text a:hover{text-decoration:underline}
        .msg.system{opacity:.6;font-style:italic}
        .msg.system .msg-nick{color:#6b5d52}
        .msg.action .msg-text{font-style:italic;color:#6b5d52}
        .msg.self .msg-nick{color:#9a77ff!important}
        .msg.notice .msg-nick{color:#cc785c!important}
        .msg.notice .msg-text{color:#cc785c}

        .input-bar{flex-shrink:0;display:flex;align-items:stretch;border-top:3px solid #6b5d52;background:rgba(255,255,255,.95)}
        .input-nick{padding:8px 10px;font-family:inherit;font-size:11px;font-weight:700;color:#9a77ff;background:rgba(154,119,255,.05);border:none;border-right:2px solid #c19a6b;flex-shrink:0;min-width:0;max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .input-msg{flex:1;padding:8px 10px;font-family:inherit;font-size:11px;font-weight:500;color:#1a1a1a;border:none;outline:none;background:transparent;min-width:0}
        .input-msg::placeholder{color:#c19a6b}
        .btn-send{padding:8px 14px;font-family:inherit;font-size:10px;font-weight:700;color:#fff;background:linear-gradient(135deg,#9a77ff,#7c5ce0);border:none;border-left:2px solid #6b5d52;cursor:pointer;text-transform:uppercase;letter-spacing:.5px;flex-shrink:0;transition:background .15s}
        .btn-send:active{background:#5a3cc0}

        .error-toast{display:none;position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:#cc785c;color:#fff;font-size:9px;font-weight:600;padding:6px 14px;border-radius:6px;z-index:200;white-space:nowrap}
        .error-toast.on{display:block}
    </style>
</head>
<body>
    <div class="shell">
        <div class="top-bar">
            <a href="../" title="Back">&#8592;</a>
            <div class="top-title" id="topTitle">IRC</div>
            <div class="top-status off" id="statusBadge">Offline</div>
        </div>

        <div class="connect-view" id="connectView">
            <div class="connect-card">
                <div class="connect-title">Join Channel</div>

                <div class="connect-label">Channel</div>
                <input class="connect-input" id="channelInput" value="#general" placeholder="#channel" maxlength="50" />

                <div class="connect-label">Nickname</div>
                <input class="connect-input" id="nickInput" placeholder="Anonymous" maxlength="16" />
                <div class="connect-hint">Peer-to-peer &middot; No server needed &middot; WebRTC</div>

                <button class="btn-connect" id="connectBtn">Join</button>
            </div>
        </div>

        <div class="chat-view" id="chatView">
            <div class="channel-bar">
                <span class="channel-name" id="channelLabel">#general</span>
                <span class="channel-topic" id="channelTopic">p2p</span>
                <span class="user-count" id="userCount"></span>
            </div>
            <div class="messages" id="messages"></div>
            <div class="input-bar">
                <div class="input-nick" id="nickDisplay"></div>
                <input class="input-msg" id="msgInput" placeholder="Type a message…" autocomplete="off" />
                <button class="btn-send" id="sendBtn">Send</button>
            </div>
        </div>

        <div class="error-toast" id="errorToast"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bugout/bugout.min.js"></script>
    <script>
    const SETTINGS_KEY = 'irc_settings';
    const STATE_KEY = 'irc_connection_state';
    const SWARM_PREFIX = 'swarm-irc-';
    const MAX_MESSAGES = 500;
    const DEFAULT_TRACKERS = [
        'wss://tracker.openwebtorrent.com',
        'wss://tracker.btorrent.xyz',
        'wss://tracker.fastcast.nz',
    ];

    const channelInput = document.getElementById('channelInput');
    const nickInput = document.getElementById('nickInput');
    const connectBtn = document.getElementById('connectBtn');
    const connectView = document.getElementById('connectView');
    const chatView = document.getElementById('chatView');
    const topTitle = document.getElementById('topTitle');
    const statusBadge = document.getElementById('statusBadge');
    const channelLabel = document.getElementById('channelLabel');
    const channelTopic = document.getElementById('channelTopic');
    const userCount = document.getElementById('userCount');
    const messagesEl = document.getElementById('messages');
    const nickDisplay = document.getElementById('nickDisplay');
    const msgInput = document.getElementById('msgInput');
    const sendBtn = document.getElementById('sendBtn');
    const errorToast = document.getElementById('errorToast');

    let bugout = null;
    let nickname = '';
    let channel = '';
    let connected = false;
    let peers = new Map(); // address -> { nick }
    let nickColors = {};

    // --- Settings persistence ---
    function loadSettings() {
        try {
            const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
            if (s.channel) channelInput.value = s.channel;
            if (s.nick) nickInput.value = s.nick;
        } catch {}
    }

    function saveSettings() {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify({
            channel: channelInput.value,
            nick: nickInput.value
        }));
    }

    function saveConnectionState(active) {
        if (active) {
            localStorage.setItem(STATE_KEY, JSON.stringify({
                channel: channel,
                nick: nickname,
                active: true,
                ts: Date.now()
            }));
        } else {
            localStorage.removeItem(STATE_KEY);
        }
    }

    function loadConnectionState() {
        try {
            const s = JSON.parse(localStorage.getItem(STATE_KEY) || 'null');
            if (!s || !s.active) return null;
            if (Date.now() - s.ts > 3600000) {
                localStorage.removeItem(STATE_KEY);
                return null;
            }
            return s;
        } catch { return null; }
    }

    // --- UI helpers ---
    function setStatus(state) {
        statusBadge.className = 'top-status ' + state;
        const labels = { on: 'Connected', connecting: 'Joining…', off: 'Offline' };
        statusBadge.textContent = labels[state] || 'Offline';
    }

    function showError(msg) {
        errorToast.textContent = msg;
        errorToast.classList.add('on');
        setTimeout(() => errorToast.classList.remove('on'), 4000);
    }

    function nickColor(nick) {
        if (nickColors[nick]) return nickColors[nick];
        const colors = ['#9a77ff','#cc785c','#3a8f6b','#89530e','#7c5ce0','#b85c3a','#c19a6b','#6b5d52','#2d7356','#d4764e'];
        let hash = 0;
        for (let i = 0; i < nick.length; i++) {
            hash = nick.charCodeAt(i) + ((hash << 5) - hash);
        }
        const color = colors[Math.abs(hash) % colors.length];
        nickColors[nick] = color;
        return color;
    }

    function formatTime(date) {
        const h = String(date.getHours()).padStart(2, '0');
        const m = String(date.getMinutes()).padStart(2, '0');
        return h + ':' + m;
    }

    function escText(text) {
        const d = document.createElement('div');
        d.textContent = text;
        return d.innerHTML;
    }

    function linkify(text) {
        const escaped = escText(text);
        return escaped.replace(
            /(https?:\/\/[^\s<>"'&]+)/g,
            function(match) {
                try {
                    const u = new URL(match);
                    if (u.protocol === 'http:' || u.protocol === 'https:') {
                        return '<a href="' + escText(match) + '" target="_blank" rel="noopener">' + escText(match) + '</a>';
                    }
                } catch {}
                return match;
            }
        );
    }

    function addMessage(nick, text, type) {
        const div = document.createElement('div');
        div.className = 'msg' + (type ? ' ' + type : '') + (nick === nickname ? ' self' : '');

        const time = document.createElement('span');
        time.className = 'msg-time';
        time.textContent = formatTime(new Date());

        const nickEl = document.createElement('span');
        nickEl.className = 'msg-nick';

        if (type === 'system') {
            nickEl.textContent = '\u2022';
        } else if (type === 'action') {
            nickEl.textContent = '* ' + nick;
            nickEl.style.color = nickColor(nick);
        } else {
            nickEl.textContent = nick;
            nickEl.style.color = nickColor(nick);
        }

        const textEl = document.createElement('span');
        textEl.className = 'msg-text';
        if (type === 'system' || type === 'notice') {
            textEl.textContent = text;
        } else {
            textEl.innerHTML = linkify(text);
        }

        div.appendChild(time);
        div.appendChild(nickEl);
        div.appendChild(textEl);
        messagesEl.appendChild(div);

        messagesEl.scrollTop = messagesEl.scrollHeight;

        while (messagesEl.children.length > MAX_MESSAGES) {
            messagesEl.removeChild(messagesEl.firstChild);
        }
    }

    function updateUserCount() {
        // +1 for self
        const count = peers.size + 1;
        userCount.textContent = count + (count === 1 ? ' user' : ' users');
    }

    // --- Bugout P2P connection ---
    function connect() {
        const chan = channelInput.value.trim();
        let nick = nickInput.value.trim();

        if (!chan) { showError('Enter a channel'); return; }

        if (!chan.startsWith('#')) channel = '#' + chan;
        else channel = chan;

        if (!nick) nick = 'user' + Math.floor(Math.random() * 9000 + 1000);
        nick = nick.replace(/[^a-zA-Z0-9_\-]/g, '').substring(0, 16);
        if (!nick) nick = 'user' + Math.floor(Math.random() * 9000 + 1000);
        nickname = nick;

        saveSettings();
        connectBtn.disabled = true;
        setStatus('connecting');

        // Switch to chat view
        connectView.classList.add('hidden');
        chatView.classList.add('active');
        channelLabel.textContent = channel;
        channelTopic.textContent = 'p2p';
        nickDisplay.textContent = nickname;
        topTitle.textContent = channel;
        msgInput.focus();
        messagesEl.replaceChildren();
        peers.clear();
        updateUserCount();

        addMessage('', 'Joining ' + channel + '…', 'system');

        try {
            bugout = new Bugout(SWARM_PREFIX + channel, {
                announce: DEFAULT_TRACKERS,
                timeout: 120000,
                heartbeat: 30000,
            });
        } catch (e) {
            showError('Failed to create swarm');
            connectBtn.disabled = false;
            setStatus('off');
            connectView.classList.remove('hidden');
            chatView.classList.remove('active');
            return;
        }

        connected = true;

        addMessage('', 'Swarm joined. Waiting for peers…', 'system');
        setStatus('on');
        saveConnectionState(true);

        // Broadcast hello periodically until we see peers
        let helloBroadcast = setInterval(() => {
            if (bugout && connected) {
                bugout.send({ t: 'hello', nick: nickname });
            } else {
                clearInterval(helloBroadcast);
            }
        }, 10000);

        // Initial hello
        setTimeout(() => {
            if (bugout && connected) {
                bugout.send({ t: 'hello', nick: nickname });
            }
        }, 2000);

        bugout.on('seen', (address) => {
            if (!peers.has(address)) {
                peers.set(address, { nick: address.substring(0, 8) });
                updateUserCount();
            }
            // Introduce ourselves to the new peer
            if (bugout) {
                bugout.send(address, { t: 'hello', nick: nickname });
            }
        });

        bugout.on('message', (address, msg) => {
            if (typeof msg !== 'object' || !msg.t) return;

            switch (msg.t) {
                case 'hello': {
                    const prev = peers.get(address);
                    const isNew = !prev || prev.nick === address.substring(0, 8);
                    peers.set(address, { nick: msg.nick });
                    if (isNew) {
                        addMessage('', msg.nick + ' joined ' + channel, 'system');
                    }
                    updateUserCount();
                    break;
                }
                case 'chat':
                    addMessage(msg.nick || address.substring(0, 8), msg.text, '');
                    break;
                case 'action':
                    addMessage(msg.nick || address.substring(0, 8), msg.text, 'action');
                    break;
                case 'nick': {
                    const peer = peers.get(address);
                    const oldNick = peer ? peer.nick : msg.old;
                    peers.set(address, { nick: msg.nick });
                    addMessage('', oldNick + ' is now known as ' + msg.nick, 'system');
                    break;
                }
                case 'leave': {
                    const peer = peers.get(address);
                    if (peer) {
                        addMessage('', peer.nick + ' left', 'system');
                        peers.delete(address);
                        updateUserCount();
                    }
                    break;
                }
            }
        });

        bugout.on('left', (address) => {
            const peer = peers.get(address);
            if (peer) {
                addMessage('', peer.nick + ' left', 'system');
                peers.delete(address);
                updateUserCount();
            }
        });

        bugout.on('timeout', (address) => {
            const peer = peers.get(address);
            if (peer) {
                addMessage('', peer.nick + ' timed out', 'system');
                peers.delete(address);
                updateUserCount();
            }
        });
    }

    function sendMessage(text) {
        if (!text || !bugout || !connected) return;

        if (text.startsWith('/')) {
            const parts = text.substring(1).split(' ');
            const cmd = parts[0].toUpperCase();
            const args = parts.slice(1).join(' ');

            switch (cmd) {
                case 'ME':
                    if (args) {
                        bugout.send({ t: 'action', nick: nickname, text: args });
                        addMessage(nickname, args, 'action');
                    }
                    break;
                case 'NICK':
                    if (args) {
                        const newNick = args.split(' ')[0].replace(/[^a-zA-Z0-9_\-]/g, '').substring(0, 16);
                        if (newNick && newNick !== nickname) {
                            const oldNick = nickname;
                            nickname = newNick;
                            nickDisplay.textContent = newNick;
                            nickInput.value = newNick;
                            bugout.send({ t: 'nick', old: oldNick, nick: newNick });
                            addMessage('', oldNick + ' is now known as ' + newNick, 'system');
                            saveSettings();
                            saveConnectionState(true);
                        }
                    }
                    break;
                case 'QUIT':
                    disconnect();
                    break;
                case 'RECONNECT':
                    addMessage('', 'Reconnecting…', 'system');
                    disconnect();
                    setTimeout(() => {
                        channelInput.value = channel;
                        nickInput.value = nickname;
                        connect();
                    }, 500);
                    break;
                case 'PEERS':
                    addMessage('', 'Connected peers: ' + peers.size, 'system');
                    peers.forEach((peer, addr) => {
                        addMessage('', '  ' + peer.nick + ' (' + addr.substring(0, 8) + '…)', 'system');
                    });
                    break;
                case 'HELP':
                    addMessage('', 'Commands: /me, /nick, /peers, /reconnect, /quit', 'system');
                    break;
                default:
                    addMessage('', 'Unknown command. Type /help for available commands.', 'system');
                    break;
            }
        } else {
            bugout.send({ t: 'chat', nick: nickname, text: text });
            addMessage(nickname, text, '');
        }
    }

    function disconnect() {
        if (bugout) {
            try { bugout.send({ t: 'leave', nick: nickname }); } catch {}
            try { bugout.close(); } catch {}
            bugout = null;
        }
        connected = false;
        peers.clear();
        setStatus('off');
        connectView.classList.remove('hidden');
        chatView.classList.remove('active');
        connectBtn.disabled = false;
        saveConnectionState(false);
    }

    // --- Event listeners ---
    connectBtn.addEventListener('click', connect);

    nickInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') connect();
    });

    channelInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') connect();
    });

    sendBtn.addEventListener('click', () => {
        const text = msgInput.value.trim();
        if (text) {
            sendMessage(text);
            msgInput.value = '';
        }
    });

    msgInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
            const text = msgInput.value.trim();
            if (text) {
                sendMessage(text);
                msgInput.value = '';
            }
        }
    });

    // Back button disconnects
    document.querySelector('.top-bar a').addEventListener('click', e => {
        if (connected) {
            e.preventDefault();
            disconnect();
        }
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        if (connected) {
            saveConnectionState(true);
        }
    });

    // Init
    loadSettings();

    // Auto-rejoin if we had an active session
    (function autoRejoin() {
        const state = loadConnectionState();
        if (state && state.active) {
            channelInput.value = state.channel;
            nickInput.value = state.nick;
            connect();
        }
    })();
    </script>
</body>
</html>
